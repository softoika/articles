---
title: "[Angular] Promiseを使うべきかObservableを使うべきかみたいな話"
emoji: "🤔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["angular", "rxjs"]
published: false
---
::: message
本記事は[Angular Advent Calendar 2020](https://qiita.com/advent-calendar/2020/angular) 4日目の記事です。
:::

AngularにはRxJSという非同期処理ライブラリがビルトインで入っています。
RxJSは非同期処理をする際にオブザーバーパターンのような恩恵を受けられるメリットがあります。
Angularの公式チュートリアルを見れば非同期処理はすべてRxJSで書かれていますが、
一方でJavaScript(ES2015以降)にはPromiseという非同期処理の仕組みがあります。

RxJSとPromiseどちらをどういうときに使えばいいのでしょうか？
僕はWebフロントエンドにAngularから入ったので、RxJS(Observable)の性質もよく考えず使った結果、
`switchMap`などのObservableを切り替えるオペレータや`combineLatest`などのObservableを組み合わせるオペレータの多用で反って読みづらいコードにしてしまった苦い経験があります。

この記事では両者の性質を踏まえた上でRxJSに向くケースとPromiseに向くケースについて考えてみたいと思います。

# Promiseの簡単なおさらい
PromiseはES2015に登場した非同期処理の仕組みです。
大まかに説明すると`Promise.then()`で非同期的な実行をすることができ、async/await構文で同期的にも書けます。
```ts
// 1→2の順で実行される
new Promise((resolve) => {setTimeout(() => resolve(2), 1000)})
  .then((n) => console.log(n));
console.log(1);
```
```ts
function asyncRandom(n: number): Promise<number> {
  return new Promise((resolve) => setTimeout(() => resolve(n), Math.random() * 1000));
}
// 実行順は毎回異なる
asyncRandom(1).then((n) => console.log(n));
asyncRandom(2).then((n) => console.log(n));
asyncRandom(3).then((n) => console.log(n));

async function run() {
  // 上から下に順番に実行される
  let n = await asyncRandom(1);
  console.log(n);
  n = await asyncRandom(2);
  console.log(n);
  n = await asyncRandom(3);
  console.log(n);
}
run();
```

# RxJSの簡単なおさらい
RxJSは[オブザーバーパターン](https://en.wikipedia.org/wiki/Observer_pattern)というソフトウェア設計手法を用いた非同期処理ライブラリです。
また、[公式ドキュメント](https://rxjs-dev.firebaseapp.com/guide/overview)に`Think of RxJS as Lodash for events.`と例えられているように、
`filter`や`map`などのオペレータを用いて宣言的に非同期的な値を操作することができるのも特徴の一つです。

# RxJSを使うメリット
RxJSを使うメリットはまさにオブザーバーパターンにあります。
オブザーバーパターンによりObservableの購読者は一度購読(subscribe)するだけで継続的に値の変更を受けることができます。
また、１つのObservableを複数箇所で購読している状況下ではそのObservableに値を流すだけで、複数の購読者に対し同時に同じ値を送ることができます。

## Observable

```ts
const obs = from([1, 2]); // 1→2と順番に値を送る

obs.subscribe(v => console.log('Observer 1:', v));
obs.subscribe(v => console.log('Observer 2:', v));

// Observer 1: 1
// Observer 1: 2
// Observer 2: 1
// Observer 2: 2
```

Observableの実用的な例としては、[ActivatedRoute](https://angular.jp/api/router/ActivatedRoute)を使ったURLに含まれるIDの継続的な取得という例があります。
例えば、`/users/:id`というルーティング設定があったとして、以下のように書くとIDが変わるごとにリクエストを送ることができます。
```ts
@Component({
  selector: 'app-user-profile',
  template: `<app-user-details *ngIf="user" [user]="user"></app-user-details>`
})
class UserProfileComponent implements OnInit {
  user?: User;

  constructor(private route: ActivatedRoute, private userService: UserService) {}

  ngOnInit() {
    this.route.paramMap.pipe(
      // ParamMap → string
      map(params => params.get('id')),
      // Observable<string> → Observable<User>
      switchMap(id => this.userService.fetch(id))
    )
    .subscribe(user => (this.user = user));
  }
}
```
[switchMap](https://rxjs-dev.firebaseapp.com/api/operators/switchMap)は別のObservableな非同期処理に切り替えるときに使います。
また、switchMapは直前のイベントが完了する前に次のイベントが発生した場合に、直前のイベントを中断して次のイベントに切り替えるという性質を持っています。
上記の例だと`id=tanaka`を受け取り`GET /users/tanaka`のレスポンスを受け取る前に、`id=suzuki`が送られてきた場合に`GET /users/tanaka`をキャンセルし、`GET /users/suzuki`のリクエストを送ります。

## Subject
RxJSの恩恵を受けるにはSubjectも欠かせない存在でしょう。
Subjectは特殊なパターンのObservableです。Observableは*read only*なObservable、Subjectは*read/write*可能なObservableと捉えるとわかりやすいです。
また、SubjectがObservableと異なる点として、Observableは購読されるまで実際に値を流すのを**保留**するのに対し、Subjectはいつ購読されるかに関わらず値を流すことができます。

以下はシンプルなObservableの例です。subscribeしている行をコメントアウトすると値が流れないことが確認できます。
@[stackblitz](https://stackblitz.com/edit/aarh3p?embed=1&file=index.ts&hideExplorer=1&devtoolsheight=100)

そしてSubjectの例です。Subjectに値が`next()`された時点でSubjectの購読者は値を受け取ることができます。途中から購読した場合はその時点以降に流された値のみ受け取ることができます。
```ts
const subject = new Subject<number>();

subject.subscribe(x => console.log('Subscriber 1:', x));

subject.next(1);
subject.next(2);

subject.subscribe(x => console.log('Subscriber 2:', x));

subject.next(3);

// Subscriber 1: 1
// Subscriber 1: 2
// Subscriber 1: 3
// Subscriber 2: 3
```

### BehaviorSubject
BehaviorSubjectはSubjectの派生型の中でもよく使うので紹介します。
BehaviorSubjectはSubjectと異なり、subscribe時に現在の値を取得することができます。
```ts
const subject = new BehaviorSubject(0); // BehaviorSubjectは初期値を指定する必要がある

subject.subscribe(x => console.log('Subscriber 1:', x));

subject.next(1);
subject.next(2);

subject.subscribe(x => console.log('Subscriber 2:', x));

subject.next(3);

// Subscriber 1: 0
// Subscriber 1: 1
// Subscriber 1: 2
// Subscriber 2: 2
// Subscriber 1: 3
// Subscriber 2: 3
```

以下は2回目以降の呼び出しではインメモリキャッシュを使うシンプルな実装例です。(別のユーザーIDの取得やキャッシュクリアは考慮しません)
```ts
export class UserService {
  // コンポーネントはngOnInitでこのuser$をsubscribeするかasyncパイプに渡すだけでいい
  get user$() {
    return this.userSubject.asObservable();
  }
  private userSubject = new BehaviorSubject<User |  null>(null);

  constructor(private httpClient: HttpClient) { }
  
  async fetch(userId: User['id']) {
    const cached = await this.user$.pipe(take(1)).toPromise();
    if (!cached) {
      const user = await this.httpClient.get<User>(`/users/${userId}`).toPromise();
      userSubject.next(user);
    }
  }

  async update(user: User) {
    const user = await this.httpClient.put<User>(`/users/${user.id}`, user);
    userSubject.next(user);
  }
}
```
この例では単方向のデータフローも実現しています。

:::details 備考
この実装にはいくつか注意点があります。

asyncパイプに`user$`のような元SubjectのObservableを渡したい場合、BehaviorSubjectにする必要があります。[[コードサンプル]](https://stackblitz.com/edit/angular-ivy-3sxjvz?file=src/app/app.component.ts)

また、実装例にある通り、Subject/BehaviorSubjectをPromiseに変換するには`take(1)`を挟む必要があります。
`toPromise()`はObservableの`complete`を待つ実装になっているためです。[[やや古いですが情報源はこちら]](https://github.com/ReactiveX/rxjs/issues/2536) [[コードサンプル]](https://stackblitz.com/edit/rxjs-mqdvar?file=index.ts)

この例では`toPromise()`を用いてPromiseに変換していますが、実は次のバージョンのRxJS v7ではdeprecatedになります(v8で消されます)。
RxJS v7/v8以降では`lastValueFrom()`/`firstValueFrom()`という関数が用意されているのでそれらを使うようにしましょう。[[参考]](https://indepth.dev/rxjs-heads-up-topromise-is-being-deprecated/)
変換が大変なのでAngularでは`ng update`でよしなにしてくれるといいですね。
:::


コンポーネントは`user$`を初期化時に購読しておけば、いつuserを取得して表示すればいいのかを気にする必要がありません。
以下はコンポーネントの実装例です
```ts
@Component({
  selector: 'app-user-profile',
  template: `
    <app-user-details
      *ngIf="user$ | async as user"
      [user]="user"
      (update)="onUpdate($event)"
    ></app-user-details>
  `
})
class UserProfileComponent implements OnInit {
  get user$() {
    return this.userService.user$
  }

  constructor(private userService: UserService) {}

  ngOnInit() {
    this.route.paramMap.pipe(
      map(params => params.get('id'))
    )
    .subscribe(id => this.userService.fetch(id));
  }

  onUpdate(user: User) {
    this.userService.update(user);
  }
}
```
コンポーネントの実装がシンプルになっていることが見て取れます。

# RxJSを使うデメリット
operatorの種類が多く、自由度が高い→同じようなことを実現するにしても書き方に差が出る
フロントエンドで１度のアクションに対して複数の非同期処理が絡む場合、複雑な書き方が要求される場合がある
switchMapやcombineLatestなど
その場合にはPromiseとasync/awaitを使った方がシンプルに書ける(経験上)
