---
title: "[Angular] Promiseを使うべきかObservableを使うべきかみたいな話"
emoji: "🤔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["angular"]
published: false
---
::: message
本記事は[Angular Advent Calendar 2020](https://qiita.com/advent-calendar/2020/angular) 4日目の記事です。
:::

AngularにはRxJSという非同期処理ライブラリがビルトインで入っています。
RxJSは非同期処理をする際にオブザーバーパターンのような恩恵を受けられるメリットがあります。
Angularの公式チュートリアルを見れば非同期処理はすべてRxJSで書かれていますが、
一方でJavaScript(ES2015以降)にはPromiseという非同期処理の仕組みがあります。

RxJSとPromiseどちらをどういうときに使えばいいのでしょうか？
僕はWebフロントエンドにAngularから入ったので、RxJS(Observable)の性質もよく考えず使った結果、
`switchMap`などのObservableを切り替えるオペレータや`combineLatest`などのObservableを組み合わせるオペレータの多用で反って読みづらいコードにしてしまった苦い経験があります。

この記事では両者の性質を踏まえた上でRxJSに向くケースとPromiseに向くケースについて考えてみたいと思います。

# Promiseの簡単なおさらい
PromiseはES2015に登場した非同期処理の仕組みです。
大まかに説明すると`Promise.then()`で非同期的な実行をすることができ、async/await構文で同期的にも書けます。
```ts
// 1→2の順で実行される
new Promise((resolve) => {setTimeout(() => resolve(2), 1000)})
  .then((n) => console.log(n));
console.log(1);
```
```ts
function asyncRandom(n: number): Promise<number> {
  return new Promise((resolve) => setTimeout(() => resolve(n), Math.random() * 1000));
}
// 実行順は毎回異なる
asyncRandom(1).then((n) => console.log(n));
asyncRandom(2).then((n) => console.log(n));
asyncRandom(3).then((n) => console.log(n));

async function run() {
  // 上から下に順番に実行される
  let n = await asyncRandom(1);
  console.log(n);
  n = await asyncRandom(2);
  console.log(n);
  n = await asyncRandom(3);
  console.log(n);
}
run();
```

# RxJSの簡単なおさらい
RxJSは[オブザーバーパターン](https://en.wikipedia.org/wiki/Observer_pattern)というソフトウェア設計手法を用いた非同期処理ライブラリです。
また、[公式ドキュメント](https://rxjs-dev.firebaseapp.com/guide/overview)に`Think of RxJS as Lodash for events.`と例えられているように、
`filter`や`map`などのオペレータを用いて宣言的に非同期的な値を操作することができるのも特徴の一つです。

# RxJSを使うメリット
RxJSを使うメリットはまさにオブザーバーパターンにあります。
オブザーバーパターンによりObservableの購読者は一度購読(subscribe)するだけで継続的に値の変更を受けることができます。
また、１つのObservableを複数箇所で購読している状況下ではそのObservableに値を流すだけで、複数の購読者に対し同時に同じ値を送ることができます。

## Observable

```ts
const obs = from([1, 2]); // 1→2と順番に値を送る

obs.subscribe(v => console.log('Observer 1:', v));
obs.subscribe(v => console.log('Observer 2:', v));

// Observer 1: 1
// Observer 1: 2
// Observer 2: 1
// Observer 2: 2
```

Observableの実用的な例としては、[ActivatedRoute](https://angular.jp/api/router/ActivatedRoute)を使ったURLに含まれるIDの継続的な取得という例があります。
例えば、`/users/:id`というルーティング設定があったとして、以下のように書くとIDが変わるごとにリクエストを送ることができます。
```ts
@Component({
  selector: 'app-user-profile',
  template: `<app-user-details *ngIf="user" [user]="user"></app-user-details>`
})
class UserProfileComponent implements OnInit {
  user?: User;

  constructor(private route: ActivatedRoute, private userService: UserService) {}

  ngOnInit() {
    this.route.paramMap.pipe(
      // ParamMap → string
      map(params => params.get('id')),
      // Observable<string> → Observable<User>
      switchMap(id => this.userService.fetch(id))
    )
    .subscribe(user => (this.user = user));
  }
}
```
[switchMap](https://rxjs-dev.firebaseapp.com/api/operators/switchMap)は別のObservableな非同期処理に切り替えるときに使います。
また、switchMapは直前のイベントが完了する前に次のイベントが発生した場合に、直前のイベントを中断して次のイベントに切り替えるという性質を持っています。
上記の例だと`id=tanaka`を受け取り`GET /users/tanaka`のレスポンスを受け取る前に、`id=suzuki`が送られてきた場合に`GET /users/tanaka`をキャンセルし、`GET /users/suzuki`のリクエストを送ります。

## Subject
## asyncパイプ
# RxJSを使うデメリット
operatorの種類が多く、自由度が高い→同じようなことを実現するにしても書き方に差が出る
フロントエンドで１度のアクションに対して複数の非同期処理が絡む場合、複雑な書き方が要求される場合がある
switchMapやcombineLatestなど
その場合にはPromiseとasync/awaitを使った方がシンプルに書ける(経験上)
